/*
 * ExportReport.cpp - TaskJuggler
 *
 * Copyright (c) 2002 by Chris Schlaeger <cs@suse.de>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * $Id$
 */

#include <config.h>

#include <qfile.h>
#include <qmap.h>

#include "taskjuggler.h"
#include "Project.h"
#include "Task.h"
#include "Resource.h"
#include "Booking.h"
#include "BookingList.h"
#include "ExportReport.h"
#include "ExpressionTree.h"
#include "Operation.h"
#include "CustomAttributeDefinition.h"
#include "TextAttribute.h"
#include "ReferenceAttribute.h"

#define KW(a) a

static QMap<QString, int> TaskAttributeDict;
typedef enum TADs { TA_FLAGS = 0, TA_NOTE, TA_PRIORITY, TA_MINSTART,
    TA_MAXSTART, TA_MINEND, TA_MAXEND, TA_COMPLETE, TA_RESPONSIBLE,
    TA_DEPENDS };

ExportReport::ExportReport(Project* p, const QString& f,
                           const QString& df, int dl) :
    Report(p, f, df, dl)
{
    if (TaskAttributeDict.empty())
    {
        TaskAttributeDict[KW("complete")] = TA_COMPLETE;
        TaskAttributeDict[KW("depends")] = TA_DEPENDS;
        TaskAttributeDict[KW("flags")] = TA_FLAGS;
        TaskAttributeDict[KW("maxend")] = TA_MAXEND;
        TaskAttributeDict[KW("maxstart")] = TA_MAXSTART;
        TaskAttributeDict[KW("minend")] = TA_MINEND;
        TaskAttributeDict[KW("minstart")] = TA_MINSTART;
        TaskAttributeDict[KW("note")] = TA_NOTE;
        TaskAttributeDict[KW("priority")] = TA_PRIORITY;
        TaskAttributeDict[KW("responsible")] = TA_RESPONSIBLE;
    }
    // show all tasks
    hideTask = new ExpressionTree(new Operation(0));
    // hide all resources
    hideResource = new ExpressionTree(new Operation(1));

    taskSortCriteria[0] = CoreAttributesList::TreeMode;
    taskSortCriteria[1] = CoreAttributesList::StartUp;
    taskSortCriteria[2] = CoreAttributesList::EndUp;
    resourceSortCriteria[0] = CoreAttributesList::TreeMode;
    resourceSortCriteria[1] = CoreAttributesList::IdUp;
}

bool
ExportReport::generate()
{
    if (!open())
        return FALSE;

    s << "/* This file has been generated by TaskJuggler " << VERSION << endl
      << " * For details about TaskJuggler see " << endl
      << " * " << TJURL << endl
      << " */" << endl;
/*
    generateCustomAttributeDeclaration("task", 
                                       project->getTaskAttributeDict());
    generateCustomAttributeDeclaration("resource",
                                       project->getResourceAttributeDict());
    generateCustomAttributeDeclaration("account",
                                       project->getAccountAttributeDict());
*/

    TaskList filteredTaskList;
    filterTaskList(filteredTaskList, 0, hideTask, rollUpTask);
    sortTaskList(filteredTaskList);

    ResourceList filteredResourceList;
    filterResourceList(filteredResourceList, 0, hideResource, rollUpResource);
    sortResourceList(filteredResourceList);

    generateTaskList(filteredTaskList, filteredResourceList);
    generateTaskAttributeList(filteredTaskList);
    generateResourceList(filteredTaskList, filteredResourceList);
    
    f.close();
    return TRUE;
}

bool
ExportReport::generateCustomAttributeDeclaration(const QString& propertyName,
    QDictIterator<CustomAttributeDefinition> it)
{
    if (!it.current())
        return TRUE;
    s << "  extend " << propertyName << " {" << endl;
    for ( ; it.current(); ++it)
    {
        s << "    ";
        switch (it.current()->getType())
        {
            case CAT_Text:
                s << "text";
                break;
            case CAT_Reference:
                s << "reference";
                break;
            default:
                qFatal("ExportReport::generateCustomAttributeDeclaration: "
                       "Unknown CAT %d", it.current()->getType());
                return FALSE;
        }
        s << " " << it.currentKey() 
            << " \"" << it.current()->getName() << "\" " << endl;
    }
    s << "  }" << endl;

    return TRUE;
}

bool
ExportReport::generateTaskList(TaskList& filteredTaskList,
                               ResourceList&)
{
    for (TaskListIterator tli(filteredTaskList); *tli != 0; ++tli)
    {
        QString start = time2rfc((*tli)->getStart(Task::Plan));
        QString end = time2rfc((*tli)->getEnd(Task::Plan) + 1);

        s << "task " << stripTaskRoot((*tli)->getId()) 
            << " \"" << (*tli)->getName() << "\"" << " {" << endl; 
        /* If a container task has sub tasks that are exported as well, we do
         * not export start/end date for those container tasks. */
        bool taskHasNoSubTasks = TRUE;
        for (TaskListIterator stli((*tli)->getSubListIterator()); 
             *stli != 0; ++stli)
        {
            if (filteredTaskList.findRef(*stli) >= 0)
            {
                taskHasNoSubTasks = FALSE;
                break;
            }
        }
        if (taskHasNoSubTasks)
        {
            s << "  start " << start << endl
                << "  end " << end << endl;
            if ((*tli)->getScheduled(Task::Plan))
                s << "  planscheduled" << endl;
            // TODO: Fix scenario handling
            if (scenarios.count() > 1)
            {
                start = time2rfc((*tli)->getStart(1));
                end = time2rfc((*tli)->getEnd(Task::Actual) + 1);
                s << "  actualstart " << start << endl
                    << "  actualend " << end << endl;
                if ((*tli)->getScheduled(Task::Actual))
                    s << "  actualscheduled" << endl;
            }
        }

        s << "  projectid " << (*tli)->getProjectId() << endl;
        if ((*tli)->isMilestone())
            s << "  milestone " << endl;
        
        for (QStringList::Iterator it = taskAttributes.begin(); 
             it != taskAttributes.end(); ++it)
        {
            if (!TaskAttributeDict.contains(*it))
                continue;
            switch (TaskAttributeDict[*it])
            {
                case TA_DEPENDS:
                    if ((*tli)->hasPrevious())
                    {
                        bool first = TRUE;
                        for (TaskListIterator
                             pli((*tli)->getPreviousIterator()); *pli != 0;
                             ++pli)
                        {
                            /* Save current list item since findRef() modifies
                             * it. Remember, we are still iterating the list.
                             */
                            CoreAttributes* curr = filteredTaskList.current();
                            if (filteredTaskList.findRef(*pli) > -1 &&
                                !((*tli)->getParent() != 0 &&
                                  (*tli)->getParent()->hasPrevious(*pli)))
                            {
                                if (first)
                                {
                                    s << "  depends ";
                                    first = FALSE;
                                }
                                else
                                    s << ", ";
                                s << stripTaskRoot((*pli)->getId());
                            }
                            /* Restore current list item to continue
                             * iteration. */
                            filteredTaskList.findRef(curr);
                        }
                        if (!first)
                            s << endl;
                    }
                    break;
                default:
                    break;
            }
        }
        
        s << "}" << endl;
    }

    return TRUE;
}

bool
ExportReport::generateTaskAttributeList(TaskList& filteredTaskList)
{
    if (taskAttributes.isEmpty())
        return TRUE;

    if (taskAttributes.contains("flags"))
    {
        FlagList allFlags;
        for (TaskListIterator tli(filteredTaskList); *tli != 0; ++tli)
        {
            QStringList fl = (*tli)->getFlagList();
            for (QStringList::Iterator jt = fl.begin();
                 jt != fl.end(); ++jt)
            {
                if (allFlags.find(*jt) == allFlags.end())
                    allFlags.append(*jt);
            }

        }
        if (allFlags.begin() != allFlags.end())
        {
            s << "flags ";
            for (QStringList::Iterator it = allFlags.begin();
                 it != allFlags.end(); ++it)
            {
                if (it != allFlags.begin())
                    s << ", ";
                s << *it;
            }
            s << endl;
        }
    }

    for (TaskListIterator tli(filteredTaskList); *tli != 0; ++tli)
    {
        s << "supplement task " << stripTaskRoot((*tli)->getId()) << " {" 
            << endl;
        for (QStringList::Iterator it = taskAttributes.begin(); 
             it != taskAttributes.end(); ++it)
        {
            if (!TaskAttributeDict.contains(*it))
            {
                if ((*tli)->getCustomAttribute(*it))
                {
                    s << "  " << *it << " ";
                    const CustomAttribute* ca = 
                        (*tli)->getCustomAttribute(*it);
                    switch (ca->getType())
                    {
                        case CAT_Text:
                            s << "\"" << ((const TextAttribute*) ca)->getText()
                                << "\"" << endl;
                            break;
                        case CAT_Reference:
                            {
                                const ReferenceAttribute* a = 
                                    (const ReferenceAttribute*) ca;
                                s << "\"" << a->getUrl() << "\" { label \"" 
                                    << a->getUrl() << "\" }" << endl;
                                break;
                            }
                        default:
                            qFatal("ExportReport::"
                                   "generateTaskAttributeList: "
                                   "Unknown CAT %d", 
                                   ca->getType());
                    }
                }
                continue;
            }
            switch (TaskAttributeDict[*it])
            {
                case TA_FLAGS:
                    {
                        if ((*tli)->getFlagList().empty())
                            break;
                        s << "  flags ";
                        QStringList fl = (*tli)->getFlagList();
                        bool first = TRUE;
                        for (QStringList::Iterator jt = fl.begin();
                             jt != fl.end(); ++jt)
                        {
                            if (!first)
                                s << ", ";
                            else
                                first = FALSE;
                            s << *jt;
                        }
                        s << endl;
                        break;
                    }
                case TA_NOTE:
                    if ((*tli)->getNote() != "")
                        s << "  note \"" << (*tli)->getNote() << "\"" << endl;
                    break;
                case TA_MINSTART:
                    if ((*tli)->getMinStart() != 0)
                        s << "  minstart " << time2rfc((*tli)->getMinStart()) 
                            << endl;
                    break;
                case TA_MAXSTART:
                    if ((*tli)->getMaxStart() != 0)
                        s << "  maxstart " << time2rfc((*tli)->getMaxStart()) 
                            << endl;
                    break;
                case TA_MINEND:
                    if ((*tli)->getMinEnd() != 0)
                        s << "  minend " << time2rfc((*tli)->getMinEnd())
                            << endl;
                    break;
                case TA_MAXEND:
                    if ((*tli)->getMaxEnd() != 0)
                        s << "  maxend " << time2rfc((*tli)->getMaxEnd())
                            << endl;
                    break;
                case TA_COMPLETE:
                    // TODO: Fix scenario handling
                    if ((*tli)->getComplete(Task::Plan) >= 0.0)
                        s << "  complete " 
                            << (int) (*tli)->getComplete(Task::Plan) << endl;
                    break;
                case TA_RESPONSIBLE:
                    if ((*tli)->getResponsible())
                        s << "  responsible " 
                            << (*tli)->getResponsible()->getId() << endl;
                    break;
                case TA_DEPENDS:
                    // handled in generateTaskList
                    break;
                default:
                    return FALSE;
            }
        }

        s << "}" << endl;
    }

    return TRUE;
}

bool
ExportReport::generateResourceList(TaskList& filteredTaskList,
                                   ResourceList& filteredResourceList)
{
    for (ResourceListIterator rli(filteredResourceList); *rli != 0; ++rli)
    {
        bool first = TRUE;
        for (int sc = Task::Plan; sc <= Task::Actual; sc++)
        {
            // TODO: Fix scenario handling
            if (sc == Task::Actual)
                continue;
            BookingList bl = (*rli)->getJobs(sc);
            bl.setAutoDelete(TRUE);
            if (bl.isEmpty())
                continue;
            for (BookingListIterator bli(bl); *bli != 0; ++bli)
            {
                if (filteredTaskList.findRef((*bli)->getTask()) >= 0)
                {
                    if (first)
                    {
                        s << "supplement resource " << (*rli)->getId() 
                            << " {" << endl;
                        first = FALSE;
                    }
                    QString start = time2rfc((*bli)->getStart());
                    QString end = time2rfc((*bli)->getEnd() + 1);
                    switch (sc)
                    {
                        case Task::Plan:
                            s << "  planbooking ";
                            break;
                        case Task::Actual:
                            s << "  actualbooking ";
                            break;
                        default:
                            qFatal("ExportReport::generateResourceList: "
                                   "Unknown scenario");
                    }
                    s << start << " " << end 
                        << " " << stripTaskRoot((*bli)->getTask()->getId()) 
                        << endl;
                }
            }
        }
        if (!first)
            s << "}" << endl;
    }

    return TRUE;
}

bool
ExportReport::addTaskAttribute(const QString& ta)
{
    /* Make sure the 'ta' is a valid attribute name and that we don't
     * insert it twice into the list. Trying to insert it twice it not an
     * error though. */
    if (TaskAttributeDict.find(ta) == TaskAttributeDict.end() &&
        project->getTaskAttribute(ta) == 0)
        return FALSE;

    if (taskAttributes.findIndex(ta) >= 0)
        return TRUE;
    taskAttributes.append(ta);
    return TRUE;
}

